/*
 * Generated by gen_defines.py
 *
 * DTS input file:
 *   /home/adam/projects/zephyr/zephyr-mini/dts/mini.dts
 *
 * Directories with bindings:
 *   /home/adam/projects/zephyr/zephyr-mini/dts/bindings
 *
 * Node dependency ordering (ordinal and path):
 *   0   /
 *   1   /i2c@40003000
 *   2   /i2c@40003000/sensor@76
 *
 * Definitions derived from these nodes in dependency order are next,
 * followed by /chosen nodes.
 */

/* Used to remove brackets from around a single argument */
#define DT_DEBRACKET_INTERNAL(...) __VA_ARGS__

/*
 * Devicetree node: /
 *
 * Node identifier: DT_N
 */

/* Node's full path: */
#define DT_N_PATH "/"

/* Node's name with unit-address: */
#define DT_N_FULL_NAME "/"
#define DT_N_FULL_NAME_UNQUOTED /
#define DT_N_FULL_NAME_TOKEN _
#define DT_N_FULL_NAME_UPPER_TOKEN _

/* Helpers for dealing with node labels: */
#define DT_N_NODELABEL_NUM 0
#define DT_N_FOREACH_NODELABEL(fn) 
#define DT_N_FOREACH_NODELABEL_VARGS(fn, ...) 
#define DT_N_FOREACH_ANCESTOR(fn) 

/* Helper macros for child nodes of this node. */
#define DT_N_CHILD_NUM 1
#define DT_N_CHILD_NUM_STATUS_OKAY 1
#define DT_N_FOREACH_CHILD(fn) fn(DT_N_S_i2c_40003000)
#define DT_N_FOREACH_CHILD_SEP(fn, sep) fn(DT_N_S_i2c_40003000)
#define DT_N_FOREACH_CHILD_VARGS(fn, ...) fn(DT_N_S_i2c_40003000, __VA_ARGS__)
#define DT_N_FOREACH_CHILD_SEP_VARGS(fn, sep, ...) fn(DT_N_S_i2c_40003000, __VA_ARGS__)
#define DT_N_FOREACH_CHILD_STATUS_OKAY(fn) fn(DT_N_S_i2c_40003000)
#define DT_N_FOREACH_CHILD_STATUS_OKAY_SEP(fn, sep) fn(DT_N_S_i2c_40003000)
#define DT_N_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) fn(DT_N_S_i2c_40003000, __VA_ARGS__)
#define DT_N_FOREACH_CHILD_STATUS_OKAY_SEP_VARGS(fn, sep, ...) fn(DT_N_S_i2c_40003000, __VA_ARGS__)

/* Node's hash: */
#define DT_N_HASH il7asoJjJEMhngUeSt4tHVu8Zxx4EFG_FDeJfL3_oPE

/* Node's dependency ordinal: */
#define DT_N_ORD 0
#define DT_N_ORD_STR_SORTABLE 00000

/* Ordinals for what this node depends on directly: */
#define DT_N_REQUIRES_ORDS /* nothing */

/* Ordinals for what depends directly on this node: */
#define DT_N_SUPPORTS_ORDS \
	1, /* /i2c@40003000 */

/* Existence and alternate IDs: */
#define DT_N_EXISTS 1
#define DT_N_INST_0_myvendor_miniboard DT_N

/* Macros for properties that are special in the specification: */
#define DT_N_REG_NUM 0
#define DT_N_RANGES_NUM 0
#define DT_N_FOREACH_RANGE(fn) 
#define DT_N_IRQ_NUM 0
#define DT_N_IRQ_LEVEL 0
#define DT_N_COMPAT_MATCHES_myvendor_miniboard 1
#define DT_N_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_PINCTRL_NUM 0

/* Generic property macros: */
#define DT_N_P_compatible {"myvendor,miniboard"}
#define DT_N_P_compatible_IDX_0_EXISTS 1
#define DT_N_P_compatible_IDX_0 "myvendor,miniboard"
#define DT_N_P_compatible_IDX_0_STRING_UNQUOTED myvendor,miniboard
#define DT_N_P_compatible_IDX_0_STRING_TOKEN myvendor_miniboard
#define DT_N_P_compatible_IDX_0_STRING_UPPER_TOKEN MYVENDOR_MINIBOARD
#define DT_N_P_compatible_FOREACH_PROP_ELEM(fn) fn(DT_N, compatible, 0)
#define DT_N_P_compatible_FOREACH_PROP_ELEM_SEP(fn, sep) fn(DT_N, compatible, 0)
#define DT_N_P_compatible_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N, compatible, 0, __VA_ARGS__)
#define DT_N_P_compatible_FOREACH_PROP_ELEM_SEP_VARGS(fn, sep, ...) fn(DT_N, compatible, 0, __VA_ARGS__)
#define DT_N_P_compatible_LEN 1
#define DT_N_P_compatible_EXISTS 1

/*
 * Devicetree node: /i2c@40003000
 *
 * Node identifier: DT_N_S_i2c_40003000
 *
 * Binding (compatible = myvendor,i2c-controller):
 *   /home/adam/projects/zephyr/zephyr-mini/dts/bindings/myvendor,i2c-controller.yaml
 *
 * (Descriptions have moved to the Devicetree Bindings Index
 * in the documentation.)
 */

/* Node's full path: */
#define DT_N_S_i2c_40003000_PATH "/i2c@40003000"

/* Node's name with unit-address: */
#define DT_N_S_i2c_40003000_FULL_NAME "i2c@40003000"
#define DT_N_S_i2c_40003000_FULL_NAME_UNQUOTED i2c@40003000
#define DT_N_S_i2c_40003000_FULL_NAME_TOKEN i2c_40003000
#define DT_N_S_i2c_40003000_FULL_NAME_UPPER_TOKEN I2C_40003000

/* Node parent (/) identifier: */
#define DT_N_S_i2c_40003000_PARENT DT_N

/* Node's index in its parent's list of children: */
#define DT_N_S_i2c_40003000_CHILD_IDX 0

/* Helpers for dealing with node labels: */
#define DT_N_S_i2c_40003000_NODELABEL_NUM 1
#define DT_N_S_i2c_40003000_FOREACH_NODELABEL(fn) fn(i2c0)
#define DT_N_S_i2c_40003000_FOREACH_NODELABEL_VARGS(fn, ...) fn(i2c0, __VA_ARGS__)
#define DT_N_S_i2c_40003000_FOREACH_ANCESTOR(fn) fn(DT_N)

/* Helper macros for child nodes of this node. */
#define DT_N_S_i2c_40003000_CHILD_NUM 1
#define DT_N_S_i2c_40003000_CHILD_NUM_STATUS_OKAY 1
#define DT_N_S_i2c_40003000_FOREACH_CHILD(fn) fn(DT_N_S_i2c_40003000_S_sensor_76)
#define DT_N_S_i2c_40003000_FOREACH_CHILD_SEP(fn, sep) fn(DT_N_S_i2c_40003000_S_sensor_76)
#define DT_N_S_i2c_40003000_FOREACH_CHILD_VARGS(fn, ...) fn(DT_N_S_i2c_40003000_S_sensor_76, __VA_ARGS__)
#define DT_N_S_i2c_40003000_FOREACH_CHILD_SEP_VARGS(fn, sep, ...) fn(DT_N_S_i2c_40003000_S_sensor_76, __VA_ARGS__)
#define DT_N_S_i2c_40003000_FOREACH_CHILD_STATUS_OKAY(fn) fn(DT_N_S_i2c_40003000_S_sensor_76)
#define DT_N_S_i2c_40003000_FOREACH_CHILD_STATUS_OKAY_SEP(fn, sep) fn(DT_N_S_i2c_40003000_S_sensor_76)
#define DT_N_S_i2c_40003000_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) fn(DT_N_S_i2c_40003000_S_sensor_76, __VA_ARGS__)
#define DT_N_S_i2c_40003000_FOREACH_CHILD_STATUS_OKAY_SEP_VARGS(fn, sep, ...) fn(DT_N_S_i2c_40003000_S_sensor_76, __VA_ARGS__)

/* Node's hash: */
#define DT_N_S_i2c_40003000_HASH yNG3kpz7tmxk3jebixLSzHz9twBP88mju9KsioB9QQY

/* Node's dependency ordinal: */
#define DT_N_S_i2c_40003000_ORD 1
#define DT_N_S_i2c_40003000_ORD_STR_SORTABLE 00001

/* Ordinals for what this node depends on directly: */
#define DT_N_S_i2c_40003000_REQUIRES_ORDS \
	0, /* / */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_i2c_40003000_SUPPORTS_ORDS \
	2, /* /i2c@40003000/sensor@76 */

/* Existence and alternate IDs: */
#define DT_N_S_i2c_40003000_EXISTS 1
#define DT_N_INST_0_myvendor_i2c_controller DT_N_S_i2c_40003000
#define DT_N_NODELABEL_i2c0                 DT_N_S_i2c_40003000

/* Macros for properties that are special in the specification: */
#define DT_N_S_i2c_40003000_REG_NUM 1
#define DT_N_S_i2c_40003000_REG_IDX_0_EXISTS 1
#define DT_N_S_i2c_40003000_REG_IDX_0_VAL_ADDRESS 1073754112 /* 0x40003000 */
#define DT_N_S_i2c_40003000_REG_IDX_0_VAL_SIZE 4096 /* 0x1000 */
#define DT_N_S_i2c_40003000_RANGES_NUM 0
#define DT_N_S_i2c_40003000_FOREACH_RANGE(fn) 
#define DT_N_S_i2c_40003000_IRQ_NUM 0
#define DT_N_S_i2c_40003000_IRQ_LEVEL 0
#define DT_N_S_i2c_40003000_COMPAT_MATCHES_myvendor_i2c_controller 1
#define DT_N_S_i2c_40003000_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_i2c_40003000_PINCTRL_NUM 0

/* Generic property macros: */
#define DT_N_S_i2c_40003000_P_reg {1073754112 /* 0x40003000 */, 4096 /* 0x1000 */}
#define DT_N_S_i2c_40003000_P_reg_IDX_0_EXISTS 1
#define DT_N_S_i2c_40003000_P_reg_IDX_0 1073754112
#define DT_N_S_i2c_40003000_P_reg_IDX_1_EXISTS 1
#define DT_N_S_i2c_40003000_P_reg_IDX_1 4096
#define DT_N_S_i2c_40003000_P_reg_EXISTS 1
#define DT_N_S_i2c_40003000_P_status "okay"
#define DT_N_S_i2c_40003000_P_status_STRING_UNQUOTED okay
#define DT_N_S_i2c_40003000_P_status_STRING_TOKEN okay
#define DT_N_S_i2c_40003000_P_status_STRING_UPPER_TOKEN OKAY
#define DT_N_S_i2c_40003000_P_status_IDX_0 "okay"
#define DT_N_S_i2c_40003000_P_status_IDX_0_EXISTS 1
#define DT_N_S_i2c_40003000_P_status_IDX_0_ENUM_IDX 1
#define DT_N_S_i2c_40003000_P_status_IDX_0_ENUM_VAL_okay_EXISTS 1
#define DT_N_S_i2c_40003000_P_status_FOREACH_PROP_ELEM(fn) fn(DT_N_S_i2c_40003000, status, 0)
#define DT_N_S_i2c_40003000_P_status_FOREACH_PROP_ELEM_SEP(fn, sep) fn(DT_N_S_i2c_40003000, status, 0)
#define DT_N_S_i2c_40003000_P_status_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_i2c_40003000, status, 0, __VA_ARGS__)
#define DT_N_S_i2c_40003000_P_status_FOREACH_PROP_ELEM_SEP_VARGS(fn, sep, ...) fn(DT_N_S_i2c_40003000, status, 0, __VA_ARGS__)
#define DT_N_S_i2c_40003000_P_status_LEN 1
#define DT_N_S_i2c_40003000_P_status_EXISTS 1
#define DT_N_S_i2c_40003000_P_compatible {"myvendor,i2c-controller"}
#define DT_N_S_i2c_40003000_P_compatible_IDX_0_EXISTS 1
#define DT_N_S_i2c_40003000_P_compatible_IDX_0 "myvendor,i2c-controller"
#define DT_N_S_i2c_40003000_P_compatible_IDX_0_STRING_UNQUOTED myvendor,i2c-controller
#define DT_N_S_i2c_40003000_P_compatible_IDX_0_STRING_TOKEN myvendor_i2c_controller
#define DT_N_S_i2c_40003000_P_compatible_IDX_0_STRING_UPPER_TOKEN MYVENDOR_I2C_CONTROLLER
#define DT_N_S_i2c_40003000_P_compatible_FOREACH_PROP_ELEM(fn) fn(DT_N_S_i2c_40003000, compatible, 0)
#define DT_N_S_i2c_40003000_P_compatible_FOREACH_PROP_ELEM_SEP(fn, sep) fn(DT_N_S_i2c_40003000, compatible, 0)
#define DT_N_S_i2c_40003000_P_compatible_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_i2c_40003000, compatible, 0, __VA_ARGS__)
#define DT_N_S_i2c_40003000_P_compatible_FOREACH_PROP_ELEM_SEP_VARGS(fn, sep, ...) fn(DT_N_S_i2c_40003000, compatible, 0, __VA_ARGS__)
#define DT_N_S_i2c_40003000_P_compatible_LEN 1
#define DT_N_S_i2c_40003000_P_compatible_EXISTS 1
#define DT_N_S_i2c_40003000_P_zephyr_deferred_init 0
#define DT_N_S_i2c_40003000_P_zephyr_deferred_init_EXISTS 1

/*
 * Devicetree node: /i2c@40003000/sensor@76
 *
 * Node identifier: DT_N_S_i2c_40003000_S_sensor_76
 */

/* Node's full path: */
#define DT_N_S_i2c_40003000_S_sensor_76_PATH "/i2c@40003000/sensor@76"

/* Node's name with unit-address: */
#define DT_N_S_i2c_40003000_S_sensor_76_FULL_NAME "sensor@76"
#define DT_N_S_i2c_40003000_S_sensor_76_FULL_NAME_UNQUOTED sensor@76
#define DT_N_S_i2c_40003000_S_sensor_76_FULL_NAME_TOKEN sensor_76
#define DT_N_S_i2c_40003000_S_sensor_76_FULL_NAME_UPPER_TOKEN SENSOR_76

/* Node parent (/i2c@40003000) identifier: */
#define DT_N_S_i2c_40003000_S_sensor_76_PARENT DT_N_S_i2c_40003000

/* Node's index in its parent's list of children: */
#define DT_N_S_i2c_40003000_S_sensor_76_CHILD_IDX 0

/* Helpers for dealing with node labels: */
#define DT_N_S_i2c_40003000_S_sensor_76_NODELABEL_NUM 0
#define DT_N_S_i2c_40003000_S_sensor_76_FOREACH_NODELABEL(fn) 
#define DT_N_S_i2c_40003000_S_sensor_76_FOREACH_NODELABEL_VARGS(fn, ...) 
#define DT_N_S_i2c_40003000_S_sensor_76_FOREACH_ANCESTOR(fn) fn(DT_N_S_i2c_40003000) fn(DT_N)

/* Helper macros for child nodes of this node. */
#define DT_N_S_i2c_40003000_S_sensor_76_CHILD_NUM 0
#define DT_N_S_i2c_40003000_S_sensor_76_CHILD_NUM_STATUS_OKAY 0
#define DT_N_S_i2c_40003000_S_sensor_76_FOREACH_CHILD(fn) 
#define DT_N_S_i2c_40003000_S_sensor_76_FOREACH_CHILD_SEP(fn, sep) 
#define DT_N_S_i2c_40003000_S_sensor_76_FOREACH_CHILD_VARGS(fn, ...) 
#define DT_N_S_i2c_40003000_S_sensor_76_FOREACH_CHILD_SEP_VARGS(fn, sep, ...) 
#define DT_N_S_i2c_40003000_S_sensor_76_FOREACH_CHILD_STATUS_OKAY(fn) 
#define DT_N_S_i2c_40003000_S_sensor_76_FOREACH_CHILD_STATUS_OKAY_SEP(fn, sep) 
#define DT_N_S_i2c_40003000_S_sensor_76_FOREACH_CHILD_STATUS_OKAY_VARGS(fn, ...) 
#define DT_N_S_i2c_40003000_S_sensor_76_FOREACH_CHILD_STATUS_OKAY_SEP_VARGS(fn, sep, ...) 

/* Node's hash: */
#define DT_N_S_i2c_40003000_S_sensor_76_HASH bZD5sPHJsS6tWRUZ1NSlfpHirjK9eHe6v9DV_nbwyxE

/* Node's dependency ordinal: */
#define DT_N_S_i2c_40003000_S_sensor_76_ORD 2
#define DT_N_S_i2c_40003000_S_sensor_76_ORD_STR_SORTABLE 00002

/* Ordinals for what this node depends on directly: */
#define DT_N_S_i2c_40003000_S_sensor_76_REQUIRES_ORDS \
	1, /* /i2c@40003000 */

/* Ordinals for what depends directly on this node: */
#define DT_N_S_i2c_40003000_S_sensor_76_SUPPORTS_ORDS /* nothing */

/* Existence and alternate IDs: */
#define DT_N_S_i2c_40003000_S_sensor_76_EXISTS 1
#define DT_N_INST_0_myvendor_sensor DT_N_S_i2c_40003000_S_sensor_76

/* Macros for properties that are special in the specification: */
#define DT_N_S_i2c_40003000_S_sensor_76_REG_NUM 1
#define DT_N_S_i2c_40003000_S_sensor_76_REG_IDX_0_EXISTS 1
#define DT_N_S_i2c_40003000_S_sensor_76_REG_IDX_0_VAL_ADDRESS 118 /* 0x76 */
#define DT_N_S_i2c_40003000_S_sensor_76_RANGES_NUM 0
#define DT_N_S_i2c_40003000_S_sensor_76_FOREACH_RANGE(fn) 
#define DT_N_S_i2c_40003000_S_sensor_76_IRQ_NUM 0
#define DT_N_S_i2c_40003000_S_sensor_76_IRQ_LEVEL 0
#define DT_N_S_i2c_40003000_S_sensor_76_COMPAT_MATCHES_myvendor_sensor 1
#define DT_N_S_i2c_40003000_S_sensor_76_STATUS_okay 1

/* Pin control (pinctrl-<i>, pinctrl-names) properties: */
#define DT_N_S_i2c_40003000_S_sensor_76_PINCTRL_NUM 0

/* Generic property macros: */
#define DT_N_S_i2c_40003000_S_sensor_76_P_compatible {"myvendor,sensor"}
#define DT_N_S_i2c_40003000_S_sensor_76_P_compatible_IDX_0_EXISTS 1
#define DT_N_S_i2c_40003000_S_sensor_76_P_compatible_IDX_0 "myvendor,sensor"
#define DT_N_S_i2c_40003000_S_sensor_76_P_compatible_IDX_0_STRING_UNQUOTED myvendor,sensor
#define DT_N_S_i2c_40003000_S_sensor_76_P_compatible_IDX_0_STRING_TOKEN myvendor_sensor
#define DT_N_S_i2c_40003000_S_sensor_76_P_compatible_IDX_0_STRING_UPPER_TOKEN MYVENDOR_SENSOR
#define DT_N_S_i2c_40003000_S_sensor_76_P_compatible_FOREACH_PROP_ELEM(fn) fn(DT_N_S_i2c_40003000_S_sensor_76, compatible, 0)
#define DT_N_S_i2c_40003000_S_sensor_76_P_compatible_FOREACH_PROP_ELEM_SEP(fn, sep) fn(DT_N_S_i2c_40003000_S_sensor_76, compatible, 0)
#define DT_N_S_i2c_40003000_S_sensor_76_P_compatible_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_i2c_40003000_S_sensor_76, compatible, 0, __VA_ARGS__)
#define DT_N_S_i2c_40003000_S_sensor_76_P_compatible_FOREACH_PROP_ELEM_SEP_VARGS(fn, sep, ...) fn(DT_N_S_i2c_40003000_S_sensor_76, compatible, 0, __VA_ARGS__)
#define DT_N_S_i2c_40003000_S_sensor_76_P_compatible_LEN 1
#define DT_N_S_i2c_40003000_S_sensor_76_P_compatible_EXISTS 1
#define DT_N_S_i2c_40003000_S_sensor_76_P_reg {118 /* 0x76 */}
#define DT_N_S_i2c_40003000_S_sensor_76_P_reg_IDX_0_EXISTS 1
#define DT_N_S_i2c_40003000_S_sensor_76_P_reg_IDX_0 118
#define DT_N_S_i2c_40003000_S_sensor_76_P_reg_EXISTS 1
#define DT_N_S_i2c_40003000_S_sensor_76_P_status "okay"
#define DT_N_S_i2c_40003000_S_sensor_76_P_status_STRING_UNQUOTED okay
#define DT_N_S_i2c_40003000_S_sensor_76_P_status_STRING_TOKEN okay
#define DT_N_S_i2c_40003000_S_sensor_76_P_status_STRING_UPPER_TOKEN OKAY
#define DT_N_S_i2c_40003000_S_sensor_76_P_status_IDX_0 "okay"
#define DT_N_S_i2c_40003000_S_sensor_76_P_status_IDX_0_EXISTS 1
#define DT_N_S_i2c_40003000_S_sensor_76_P_status_IDX_0_ENUM_IDX 1
#define DT_N_S_i2c_40003000_S_sensor_76_P_status_IDX_0_ENUM_VAL_okay_EXISTS 1
#define DT_N_S_i2c_40003000_S_sensor_76_P_status_FOREACH_PROP_ELEM(fn) fn(DT_N_S_i2c_40003000_S_sensor_76, status, 0)
#define DT_N_S_i2c_40003000_S_sensor_76_P_status_FOREACH_PROP_ELEM_SEP(fn, sep) fn(DT_N_S_i2c_40003000_S_sensor_76, status, 0)
#define DT_N_S_i2c_40003000_S_sensor_76_P_status_FOREACH_PROP_ELEM_VARGS(fn, ...) fn(DT_N_S_i2c_40003000_S_sensor_76, status, 0, __VA_ARGS__)
#define DT_N_S_i2c_40003000_S_sensor_76_P_status_FOREACH_PROP_ELEM_SEP_VARGS(fn, sep, ...) fn(DT_N_S_i2c_40003000_S_sensor_76, status, 0, __VA_ARGS__)
#define DT_N_S_i2c_40003000_S_sensor_76_P_status_LEN 1
#define DT_N_S_i2c_40003000_S_sensor_76_P_status_EXISTS 1

/*
 * Chosen nodes
 */

/* Macros for iterating over all nodes and enabled nodes */
#define DT_FOREACH_HELPER(fn) fn(DT_N) fn(DT_N_S_i2c_40003000) fn(DT_N_S_i2c_40003000_S_sensor_76)
#define DT_FOREACH_OKAY_HELPER(fn) fn(DT_N) fn(DT_N_S_i2c_40003000) fn(DT_N_S_i2c_40003000_S_sensor_76)
#define DT_FOREACH_VARGS_HELPER(fn, ...) fn(DT_N, __VA_ARGS__) fn(DT_N_S_i2c_40003000, __VA_ARGS__) fn(DT_N_S_i2c_40003000_S_sensor_76, __VA_ARGS__)
#define DT_FOREACH_OKAY_VARGS_HELPER(fn, ...) fn(DT_N, __VA_ARGS__) fn(DT_N_S_i2c_40003000, __VA_ARGS__) fn(DT_N_S_i2c_40003000_S_sensor_76, __VA_ARGS__)

/*
 * Macros for compatibles with status "okay" nodes
 */
#define DT_COMPAT_HAS_OKAY_myvendor_miniboard 1
#define DT_COMPAT_HAS_OKAY_myvendor_i2c_controller 1
#define DT_COMPAT_HAS_OKAY_myvendor_sensor 1

/*
 * Macros for status "okay" instances of each compatible
 */
#define DT_N_INST_myvendor_miniboard_NUM_OKAY 1
#define DT_N_INST_myvendor_i2c_controller_NUM_OKAY 1
#define DT_N_INST_myvendor_sensor_NUM_OKAY 1
#define DT_FOREACH_OKAY_myvendor_miniboard(fn) fn(DT_N)
#define DT_FOREACH_OKAY_VARGS_myvendor_miniboard(fn, ...) fn(DT_N, __VA_ARGS__)
#define DT_FOREACH_OKAY_INST_myvendor_miniboard(fn) fn(0)
#define DT_FOREACH_OKAY_INST_VARGS_myvendor_miniboard(fn, ...) fn(0, __VA_ARGS__)
#define DT_FOREACH_OKAY_myvendor_i2c_controller(fn) fn(DT_N_S_i2c_40003000)
#define DT_FOREACH_OKAY_VARGS_myvendor_i2c_controller(fn, ...) fn(DT_N_S_i2c_40003000, __VA_ARGS__)
#define DT_FOREACH_OKAY_INST_myvendor_i2c_controller(fn) fn(0)
#define DT_FOREACH_OKAY_INST_VARGS_myvendor_i2c_controller(fn, ...) fn(0, __VA_ARGS__)
#define DT_FOREACH_OKAY_myvendor_sensor(fn) fn(DT_N_S_i2c_40003000_S_sensor_76)
#define DT_FOREACH_OKAY_VARGS_myvendor_sensor(fn, ...) fn(DT_N_S_i2c_40003000_S_sensor_76, __VA_ARGS__)
#define DT_FOREACH_OKAY_INST_myvendor_sensor(fn) fn(0)
#define DT_FOREACH_OKAY_INST_VARGS_myvendor_sensor(fn, ...) fn(0, __VA_ARGS__)

/*
 * Bus information for status "okay" nodes of each compatible
 */
